--1. 집합연산

-- employees 테이블에서 부서번호가 30번인 행들을 union과 union all로 조회하기

SELECT *
FROM EMPLOYEES
WHERE DEPARTMENT_ID =30
UNION
SELECT *
FROM EMPLOYEES
WHERE DEPARTMENT_ID =30;

SELECT *
FROM EMPLOYEES
WHERE DEPARTMENT_ID =30
UNION ALL 
SELECT *
FROM EMPLOYEES
WHERE DEPARTMENT_ID =30;

--union 으로 다른 테이블의 값들 조회가능할까?

SELECT * FROM employees;
SELECT * FROM DEPARTMENTS;


-- 오류 : 열의 수가 다르면 union을 사용할 수 없다.
SELECT * FROM EMPLOYEES e 
UNION
SELECT * FROM DEPARTMENTS d ;


--오류 : 컬럼의 타입이 일치하지 않으면 union을 사용할 수 없다.
SELECT employee_id, DEPARTMENT_ID , JOB_ID, hire_date 
FROM EMPLOYEES e 
UNION
SELECT * FROM DEPARTMENTS d ;

--컬럼의 갯수와 타입이 일치한다면 union을 사용할 수 있다.
--number, varchar2, nmber, number
--위쪽테이블의 별칭을넣어줌으로써 컬럼명을 변경가능하다.
SELECT EMPLOYEE_ID, first_name, salary, department_id
FROM EMPLOYEES e 
UNION
SELECT * FROM DEPARTMENTS d;

-- union 이 두 테이블을 합치고orderby가 실행되기 때문에 합쳐지기이전의 컬럼명이나 소속을 이용해도 정렬이 되지 않는다.
-- sql실행순서 from > on > join > where > group by > having > select > order by
-- 별칭을 붙였을 경우 sql실행순서에 따라 order by를 별칭으로 해야한다.
SELECT EMPLOYEE_ID 번호, first_name 이름, salary 숫자, department_id 번호2
FROM EMPLOYEES e 
UNION
SELECT * FROM DEPARTMENTS d
ORDER BY 번호2 ;

-- 교집합
SELECT EMPLOYEE_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 10 OR DEPARTMENT_ID = 20
INTERSECT 
SELECT EMPLOYEE_ID 
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 30 OR DEPARTMENT_ID = 10;

-- 차집합
SELECT EMPLOYEE_ID, DEPARTMENT_ID
FROM EMPLOYEES e 
WHERE e.DEPARTMENT_ID= 10 OR DEPARTMENT_ID = 30
MINUS
SELECT EMPLOYEE_ID, DEPARTMENT_ID
FROM EMPLOYEES e 
WHERE e.DEPARTMENT_ID= 10 OR DEPARTMENT_ID = 50;


SELECT EMPLOYEE_ID, DEPARTMENT_ID
FROM EMPLOYEES e 
WHERE e.DEPARTMENT_ID= 10 OR DEPARTMENT_ID = 50
MINUS
SELECT EMPLOYEE_ID, DEPARTMENT_ID
FROM EMPLOYEES e 
WHERE e.DEPARTMENT_ID= 10 OR DEPARTMENT_ID = 30;

--2. VIEW
--CREATE VIEW AS 쿼리문;
SELECT * FROM EMPLOYEES e ;

CREATE VIEW EMPLOYEE_DEPT AS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID
FROM EMPLOYEES e
WHERE DEPARTMENT_ID = 50;

SELECT * FROM EMPLOYEE_DEPT ed ;

SELECT * FROM PLAYER p ;

--PLAYER 테이블에서 나이컬럼을 추가한 뷰 만들기
-- PLAYER 테이블의 모든 컬럼에 + 나이 컬럼을 추가하여 조회하기
-- 단, 오늘 날짜기준으로 조회하며 나이컬럼이 제일 앞에 오도록 조회할것
SELECT BIRTH_DATE 
FROM PLAYER p 

SELECT SYSDATE
FROM PLAYER p ;

SELECT SYSDATE-BIRTH_DATE 
FROM PLAYER p ;

CREATE VIEW VIEW_PLAYER AS
SELECT ROUND((SYSDATE-BIRTH_DATE)/365) AGE, P.*
FROM PLAYER p;

SELECT PLAYER_NAME, BIRTH_DATE, AGE
FROM VIEW_PLAYER;

DROP VIEW EMPLOYEE_DEPT;

-- EMPLOYEES 테이블에서 사원이름과 사원의 매니저 이름이 있는 VIEW 만들기
SELECT *
FROM EMPLOYEES e LEFT JOIN EMPLOYEES e2 
ON E.MANAGER_ID = E2.EMPLOYEE_ID
ORDER BY E.EMPLOYEE_ID;

CREATE VIEW VIEW_EMPLOYEES AS
SELECT E.FIRST_NAME||' '||E.LAST_NAME 사원이름,
	e2.FIRST_NAME||' '||e2.LAST_NAME 매니저이름
FROM EMPLOYEES e LEFT JOIN EMPLOYEES e2 
ON E.MANAGER_ID = E2.EMPLOYEE_ID
ORDER BY E.EMPLOYEE_ID;

SELECT * FROM VIEW_EMPLOYEES;

CREATE TABLE WEB_CAR( 
	CAR_ID NUMBER PRIMARY KEY,
	CAR_BRAND VARCHAR2(100),
	CAR_PRICE NUMBER
);

SELECT * FROM WEB_CAR;

INSERT INTO WEB_CAR 
VALUES(1,'BMW',10);
INSERT INTO WEB_CAR 
VALUES(2,'현대',5);
INSERT INTO WEB_CAR 
VALUES(3,'기아',8);
INSERT INTO WEB_CAR 
VALUES(4,'벤츠',15);

CREATE VIEW VIEW_CAR AS
SELECT * FROM WEB_CAR;

SELECT * FROM WEB_CAR;

DELETE FROM WEB_CAR WHERE CAR_ID = 3;

SELECT * FROM VIEW_CAR;

SELECT * FROM hr.EMPLOYEES e ;

GRANT SELECT, INSERT, DELETE, UPDATE ON hr.WEB_CAR TO test;

SELECT * FROM hr.web_car;
INSERT INTO hr.web_car
values(5,'아우디',8);

DELETE FROM hr.web_car
WHERE car_id = 1;
--sys계정으로
REVOKE INSERT ON hr.web_car from test;
REVOKE SELECT, DELETE, UPDATE ON hr.web_car FROM test;

GRANT CREATE TABLE, CREATE VIEW, resource TO test; -- + SESSION  권한생성 4가지
--권한없음
INSERT INTO hr.web_car
values(6,'버스',9);


CREATE TABLE WEB_CAR1( 
	CAR_ID NUMBER PRIMARY KEY,
	CAR_BRAND VARCHAR2(100),
	CAR_PRICE NUMBER
);

SELECT * FROM web_car1;

INSERT INTO WEB_CAR1
VALUES(1,'기아',10000);

DROP USER test CASCADE;